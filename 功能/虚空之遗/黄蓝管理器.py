# 这个脚本的作用是，把黄带的关系转移到蓝带上，然后删除该黄带。
# 一般跟着图标走

# 首先 (图标+无数字) 的规则如下

# 如果 (图标+无数字) + 后面啥也不跟 的连续蓝带或单格蓝带
# 表示混合输入输出带，混合输入输出带唯一
# 所有该(图标+无数字)黄带，其分拣器投放关系都会被转移到这根带子上

# 如果 (图标+无数字) + (标记0+任意数字)的连续蓝带
# 表示长输入带，可以多条，多条则平分
# 所有该(图标+无数字)黄带，其分拣器投放关系都会被转移到长输出带上

# 如果 (图标+无数字) + (标记1+任意数字)的连续蓝带
# 表示长输出带，可以多条，多条则平分
# 所有该(图标+无数字)黄带，其分拣器抓取关系都会被转移到长输入带上

# 如果 (图标+无数字) + (回收+数字X)的连续蓝带
# 表示输入混带，混带唯一
# (图标 + 数字0-X)的将被征用，表示投放到回收带上的第X格
# 投放完成后，所有该(图标+无数字)黄带，其分拣器抓取关系都会被转移到混带上

# 如果有(图标+数字)的黄带和蓝带
# 表示混合带，混合带唯一
# 所有该(图标+该数字)黄带，其分拣器投放关系都会被转移到这根带子上
# 这一条和混带冲突，不过反正不需要，所以报错

import enum
from 功能.指鹿为马.通用 import 物品替换
from 功能.格式查找 import 蓝图内查找
import 日志
from 蓝图格式.模型 import 模型
from 蓝图格式.图标 import 图标
from 蓝图格式.建筑 import 建筑, 建筑主导接口
from 蓝图格式.额外参数 import 额外参数之传送带, 额外参数之空白

# TODO: 这里可以只扫分拣器, 这样可以少扫至少一半

class _图标分组信息:
    l_图标: 图标 # 图标, 一种图标一个class
    黄带序号: dict[int, int] # 建筑序号, 图标数字
    混合输入输出带起点: dict[int, int] # 建筑序号, 图标数字
    长输入带起点: set[int] # 建筑序号
    长输出带起点: set[int] # 建筑序号
    混带起点: int # 建筑序号
    def __init__(self, l_图标: 图标) -> None:
        self.l_图标 = l_图标
        self.黄带序号 = {}
        self.混合输入输出带起点 = {}
        self.长输入带起点 = set()
        self.长输出带起点 = set()
        self.混带起点 = -1
    
    def __repr__(self) -> str:
        return f"图标{self.l_图标}, 黄带序号{self.黄带序号}, 混合输入输出带起点{self.混合输入输出带起点}, 长输入带起点{self.长输入带起点}, 长输出带起点{self.长输出带起点}, 混带起点{self.混带起点}"

class _图标数字混合输入分组:
    # 用于处理混合输入输出带起点
    # 相同图标和数字的分一起
    图标图案: 图标
    图标数字: int
    黄带建筑序号: set[int]
    蓝带建筑序号: int # 应该是唯一
    def __init__(self, 图标图案: 图标, 图标数字: int, 蓝带建筑序号: int) -> None:
        self.图标图案 = 图标图案
        self.图标数字 = 图标数字
        self.黄带建筑序号 = set()
        self.蓝带建筑序号 = 蓝带建筑序号

    def __repr__(self):
        return f"图标{self.图标图案}, 数字{self.图标数字}, 黄带建筑序号{self.黄带建筑序号}, 蓝带建筑序号{self.蓝带建筑序号}"

class _黄蓝连接管理器:
    所有建筑: list[建筑]
    图标图标分组信息: dict[图标, _图标分组信息]
    _轮询数: int
    清除黄带标记: bool
    清除蓝带标记: bool
    def __init__(self, 蓝图或建筑群):
        self.所有建筑 = 蓝图内查找(蓝图或建筑群).所有建筑()
        self.图标图标分组信息 = {}
        self.清除黄带标记 = False
        self.清除蓝带标记 = True

    def _鉴定蓝带(self, 当前建筑: 建筑, 图标分组信息: _图标分组信息) -> _图标分组信息:
        l_当前建筑序号: int = 当前建筑.建筑序号
        l_图标图案序号: 图标 = 当前建筑.额外参数.图标ID.转int()
        l_图标数字: int = int(当前建筑.额外参数.图标数字)
        l_下个建筑序号: int = 当前建筑.输出接口.目标序号
        # 先判断下个建筑存不存在
        if l_下个建筑序号 == -1:
            图标分组信息.混合输入输出带起点[l_当前建筑序号] = l_图标数字
            return 图标分组信息
        # 判断下个建筑是不是带图标传送带
        l_下个建筑: 建筑 = self.所有建筑[l_下个建筑序号]
        if not isinstance(l_下个建筑, 额外参数之传送带):
            图标分组信息.混合输入输出带起点[l_当前建筑序号] = l_图标数字
            return 图标分组信息
        l_下个建筑的图标图案: 图标 = 当前建筑.额外参数.图标ID
        if not l_下个建筑的图标图案 == 图标("纯图标:数字0"):
            图标分组信息.长输出带起点.add(当前建筑.建筑序号)
        elif not l_下个建筑的图标图案 == 图标("纯图标:数字1"):
            图标分组信息.长输入带起点.add(当前建筑.建筑序号)
        elif not l_下个建筑的图标图案 == 图标("纯图标:回收"):
            if 图标分组信息.混带起点 != 1:
                raise ValueError(f"混带起点冲突, 图标{图标分组信息.l_图标}, 图标数字{l_图标数字}, 建筑序号{当前建筑.建筑序号}")
            图标分组信息.混带起点 = 当前建筑.建筑序号
        else:
            图标分组信息.混合输入输出带起点[l_当前建筑序号] = l_图标数字
        return 图标分组信息

    def 爪子满了就找下个蓝带_没满不变(self, 当前蓝带: 建筑 | None) -> 建筑 | None:
        if 当前蓝带 is None:
            return None
        if 当前蓝带.悠米_接口分析.分拣器数量 < 8:
            return 当前蓝带
        下节蓝带序号 = 当前蓝带.输出接口.目标序号
        if 下节蓝带序号 == -1:
            return None
        下节蓝带 = self.所有建筑[下节蓝带序号]
        if 下节蓝带.模型序号 != 模型("极速传送带"):
            return None
        物品替换(下节蓝带).为分拣器(图标("分拣器"))
        return 下节蓝带

    def 查找图标(self) -> None:
        for 当前建筑 in self.所有建筑:
            if not 当前建筑.模型序号.是传送带吗():
                continue
            if not isinstance(当前建筑.额外参数, 额外参数之传送带):
                continue
            l_图标图案: 图标 = 当前建筑.额外参数.图标ID
            if not l_图标图案.是物品吗():
                continue
            if l_图标图案 in self.图标图标分组信息:
                l_图标分组信息 = self.图标图标分组信息[l_图标图案]
            else:
                l_图标分组信息 = _图标分组信息(l_图标图案)
            l_建筑序号: int = 当前建筑.建筑序号
            l_图标数字: int = int(当前建筑.额外参数.图标数字)
            if 当前建筑.模型序号 == 模型("传送带"):
                l_图标分组信息.黄带序号[l_建筑序号] = l_图标数字
            elif 当前建筑.模型序号 == 模型("极速传送带"):
                l_图标分组信息 = self._鉴定蓝带(当前建筑, l_图标分组信息)
            else:
                pass
            self.图标图标分组信息[l_图标图案] = l_图标分组信息

    def 拆除黄带(self, 目标黄带: 建筑) -> None:
        if self.清除黄带标记:
            目标黄带.额外参数 = 额外参数之空白()
        物品替换(目标黄带).拆()

    def 清除蓝带标记并换模(self, 目标蓝带: 建筑) -> None:
        if self.清除蓝带标记:
            目标蓝带.额外参数 = 额外参数之空白()
        物品替换(目标蓝带).为分拣器(图标("分拣器"))

    def 连接一组混合输入输出带(self, 单组: _图标数字混合输入分组) -> None:
        最初蓝带: 建筑 = self.所有建筑[单组.蓝带建筑序号]
        目标蓝带 = 最初蓝带

        执行了 = False
        # 先排输出
        for 当前建筑 in self.所有建筑:
            目标蓝带 = self.爪子满了就找下个蓝带_没满不变(目标蓝带)
            if 当前建筑.输出接口.目标序号 in 单组.黄带建筑序号:
                if 目标蓝带 is None:
                    raise ValueError(f"在处理{单组.图标图案}{单组.图标数字}时\n蓝带已到尽头, 但是分拣器多于预期")
                当前建筑.输出接口.目标序号 = 目标蓝带.建筑序号
                目标蓝带.悠米_接口分析.分拣器数量 += 1
                执行了 = True
        # 再排输入
        for 当前建筑 in self.所有建筑:
            目标蓝带 = self.爪子满了就找下个蓝带_没满不变(目标蓝带)
            if 当前建筑.输入接口.目标序号 in 单组.黄带建筑序号:
                if 目标蓝带 is None:
                    当前图标 = 单组.图标图案
                    raise ValueError(f"在处理{当前图标}时\n蓝带已到尽头, 但是分拣器多于预期")
                当前建筑.输入接口.目标序号 = 目标蓝带.建筑序号
                目标蓝带.悠米_接口分析.分拣器数量 += 1
                执行了 = True
        if not 执行了:
            return
        self.清除蓝带标记并换模(最初蓝带)
        for 当前序号 in 单组.黄带建筑序号:
            self.按序号拆除黄带(当前序号)
            

    def 检查冲突(self) -> None:
        for 单图标信息 in self.图标图标分组信息.values():
            # 循环找 混合输入输出带起点, 图标数字 = 0, 的数量
            重复度 = 0
            混合输入输出带起点数量 = 0
            for 图标数字 in 单图标信息.混合输入输出带起点.items():
                if 图标数字 != 0:
                    continue
                混合输入输出带起点数量 += 1
                if 混合输入输出带起点数量 > 1:
                    raise ValueError(f"混合输入输出带起点冲突, 图标{单图标信息.l_图标}, 图标数字{图标数字}")
            if 混合输入输出带起点数量 == 1:
                重复度 += 1
            if len(单图标信息.长输入带起点) > 0:
                重复度 += 1
            if 单图标信息.混带起点 != -1:
                重复度 += 1
            if 重复度 > 1:
                raise ValueError(f"图标{单图标信息.l_图标}同时存在多种输入模式, 混合输入输出带起点{单图标信息.混合输入输出带起点}, 长输入带起点{单图标信息.长输入带起点}, 混带起点{单图标信息.混带起点}")


    def 处理混合输入输出带(self) -> None:
        for l_图标, 单图标信息 in self.图标图标分组信息.items():
            if len(单图标信息.混合输入输出带起点) == 0:
                continue
            if len(单图标信息.黄带序号) == 0:
                continue
            图标数字混合输入分组: dict[int, _图标数字混合输入分组] = {}
            # 蓝带
            for 建筑序号, 图标数字 in 单图标信息.混合输入输出带起点.items():
                if 图标数字 in 图标数字混合输入分组:
                    raise ValueError(f"混合输入输出带起点冲突, 图标{l_图标}, 图标数字{图标数字}")
                图标数字混合输入分组[图标数字] = _图标数字混合输入分组(l_图标, 图标数字, 建筑序号)
            # 黄带
            for 建筑序号, 图标数字 in 单图标信息.黄带序号.items():
                if 图标数字 not in 图标数字混合输入分组:
                    break
                图标数字混合输入分组[图标数字].黄带建筑序号.add(建筑序号)
            for 单组 in 图标数字混合输入分组.values():
                self.连接一组混合输入输出带(单组)
    
    def _找出无数字黄带(self, 单图标信息: _图标分组信息) -> set[int]:
        无数字黄带建筑序号: set[int] = set()
        for 建筑序号, 图标数字 in 单图标信息.黄带序号.items():
            if 图标数字 != 0:
                continue
            无数字黄带建筑序号.add(建筑序号)
        return 无数字黄带建筑序号

    def 寻找目标蓝带(self, 蓝带列表: list[建筑]) -> 建筑:
        当前索引 = self._轮询数 % len(蓝带列表)
        self._轮询数 += 1
        目标蓝带 = 蓝带列表[当前索引]
        目标蓝带 = self.爪子满了就找下个蓝带_没满不变(目标蓝带)
        if 目标蓝带 is None:
            蓝带列表.pop(当前索引)
            if len(蓝带列表) == 0:
                raise ValueError(f"蓝带资源耗尽, 但是分拣器多于预期")
            return self.寻找目标蓝带(当前索引, 蓝带列表)
        return 目标蓝带

    def 按序号拆除黄带(self, 序号: int):
        当前建筑 = self.所有建筑[序号]
        self.拆除黄带(当前建筑)

    def 连接输入组(self, 原黄带组: set[int], 仙输入蓝带组: set[int]) -> None:
        蓝带列表: list[建筑] = []
        for 当前序号 in 仙输入蓝带组:
            蓝带列表.append(self.所有建筑[当前序号])
        if len(蓝带列表) == 0:
            return
        self._轮询数 = 0
        for 当前建筑 in self.所有建筑:
            可能的黄带序号 = 当前建筑.输入接口.目标序号
            if 可能的黄带序号 not in 原黄带组:
                continue
            目标蓝带 = self.寻找目标蓝带(蓝带列表)
            self.按序号拆除黄带(可能的黄带序号)
            当前建筑.输入接口.目标序号 = 目标蓝带.建筑序号
            目标蓝带.悠米_接口分析.分拣器数量 += 1
            

    def 连接输出组(self, 原黄带组: set[int], 仙输出蓝带组: set[int]) -> None:
        蓝带列表: list[建筑] = []
        for 当前序号 in 仙输出蓝带组:
            蓝带列表.append(self.所有建筑[当前序号])
        if len(蓝带列表) == 0:
            return
        self._轮询数 = 0
        for 当前建筑 in self.所有建筑:
            可能的黄带序号 = 当前建筑.输入接口.目标序号
            if 可能的黄带序号 not in 原黄带组:
                continue
            目标蓝带 = self.寻找目标蓝带(蓝带列表)
            self.按序号拆除黄带(可能的黄带序号)
            当前建筑.输出接口.目标序号 = 目标蓝带.建筑序号
            目标蓝带.悠米_接口分析.分拣器数量 += 1

    # TODO: 未测试的功能
    def 处理纯输入输出带(self) -> None:
        for 单图标信息 in self.图标图标分组信息.values():
            无数字黄带建筑序号: set[int] = self._找出无数字黄带(单图标信息)
            self.连接输入组(无数字黄带建筑序号, 单图标信息.长输入带起点)
            self.连接输出组(无数字黄带建筑序号, 单图标信息.长输出带起点)

    # TODO: 未完成的函数
    def 处理混带(self) -> None:
        return
        日志.未完成的函数()
        for 单图标信息 in self.图标图标分组信息.values():
            if 单图标信息.混带起点 == -1:
                continue
            无数字黄带建筑序号: set[int] = self._找出无数字黄带(单图标信息)
            self.连接输入组(无数字黄带建筑序号, {单图标信息.混带起点})
            self.连接输出组(无数字黄带建筑序号, {单图标信息.混带起点})


def 处理黄蓝连接(蓝图或建筑群, l_清除蓝带标记: bool = True, l_清除黄带标记: bool = False) -> None:
    黄蓝连接管理器 = _黄蓝连接管理器(蓝图或建筑群)
    黄蓝连接管理器.清除蓝带标记 = l_清除蓝带标记
    黄蓝连接管理器.清除黄带标记 = l_清除黄带标记
    黄蓝连接管理器.查找图标()
    黄蓝连接管理器.检查冲突()
    黄蓝连接管理器.处理混合输入输出带()
    黄蓝连接管理器.处理纯输入输出带()
    黄蓝连接管理器.处理混带()
