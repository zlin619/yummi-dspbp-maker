from typing import List, Dict
from dataclasses import replace  # 用于复制建筑对象
import 日志
from 蓝图格式.坐标 import 传送带姿态
from 蓝图格式.建筑 import 建筑

日志.警告("你正在使用一个仍然在测试中的py文件")

def 垂直叠加(
    建筑列表: List[建筑],
    叠加次数: int,
    高度间隔: float,
    接口无效化告警: bool = False
) -> List[建筑]:
    """
    将蓝图垂直叠加多次，生成一个包含所有层建筑的新列表。
    Args:
        建筑列表: 原始建筑列表。
        叠加次数: 需要叠加的次数（如 3 表示叠加 3 份，共 4 层）。
        高度间隔: 每层之间的高度差（如 10.0）。
        接口无效化告警: 是否在接口目标无效时输出警告。
    Returns:
        叠加后的新建筑列表。
    """
    if 叠加次数 < 1:
        return

    新建筑列表 = []
    序号映射字典: Dict[int, Dict[int, int]] = {}  # {层数: {旧序号: 新序号}}

    # 生成每一层的建筑
    for 层数 in range(叠加次数 + 1):  # 从 0 到 叠加次数（包含原层）
        序号映射字典[层数] = {}
        当前层偏移 = 层数 * 高度间隔

        for 旧建筑 in 建筑列表:
            # 复制建筑并更新 Z 坐标
            新建筑 = replace(旧建筑)  # 浅拷贝
            新建筑.建筑序号 = len(新建筑列表)  # 新序号连续递增

            # 更新空间姿态（假设空间姿态是可修改的）
            if hasattr(新建筑.空间姿态, '高度Z'):
                新建筑.空间姿态.高度Z += 当前层偏移

            # 记录序号映射
            序号映射字典[层数][旧建筑.建筑序号] = 新建筑.建筑序号

            # 添加到新列表
            新建筑列表.append(新建筑)

    # 更新所有建筑的接口目标序号
    for 建筑 in 新建筑列表:
        # 同一层内的接口保持连接，不同层的接口无效化
        原始层 = 建筑.建筑序号 // len(建筑列表)  # 计算原始层数

        # 更新输入接口
        if 建筑.输入接口.目标序号 != -1:
            目标层 = 建筑.输入接口.目标序号 // len(建筑列表)
            if 目标层 == 原始层:  # 同一层
                建筑.输入接口.目标序号 = 序号映射字典[目标层][建筑.输入接口.目标序号]
            else:  # 不同层
                建筑.输入接口.目标序号 = -1
                if 接口无效化告警:
                    日志.警告(f"接口无效化: 建筑 {建筑.建筑序号} 的输入接口跨层连接已断开")

        # 更新输出接口（逻辑同上）
        if 建筑.输出接口.目标序号 != -1:
            目标层 = 建筑.输出接口.目标序号 // len(建筑列表)
            if 目标层 == 原始层:
                建筑.输出接口.目标序号 = 序号映射字典[目标层][建筑.输出接口.目标序号]
            else:
                建筑.输出接口.目标序号 = -1
                if 接口无效化告警:
                    日志.警告(f"接口无效化: 建筑 {建筑.建筑序号} 的输出接口跨层连接已断开")

    return 新建筑列表